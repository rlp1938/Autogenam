/*      autogenam.c - sets up a new project with standard GNU files
 * 	and generates AUTHORS and Makefile.am
 *
 *	Copyright 2015 Bob Parker <rlp1938@gmail.com>
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with this program; if not, write to the Free Software
 *	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *	MA 02110-1301, USA.
*/


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <getopt.h>
#include <string.h>
#include <dirent.h>	// defines PATH_MAX
#include "config.h"

const int FN_MAX = 256;

char *standards[8] = {
	"install-sh",
	"mkinstalldirs",
	"missing",
	"INSTALL",
	"COPYING",
	"compile",
	"depcomp",
	(char *)NULL
};

char * required[4] = {
	"ChangeLog",
	"NEWS",
	"README",
	(char *)NULL
};

char *path1 = "/home/";
char *path2 =  ""; // from environment variable LOGNAME ; echo $LOGNAME
char *path3 = "/Documents/Programs/Srclib/";

char *stdpath = "/home/bob/Documents/Programs/Srclib/";

char *helpmsg = "\n\tUsage:\n"
  "\tautogenam program_name main_src_name [other.c ....]\n"
  "\n\tOptions:\n"
  "\t-h, outputs this help message.\n"
  "\t-m, manpage name (If there is a manpage.)\n"
  "\t-A, file listing contributing authors if any.\n"
  "\t-d, filename to copy to /usr/local/share, if any.\n"
  "\t-x, filename, you can invoke this once for every\n"
  "\t    filename, or list all files protected by quotes and\n"
  "\t    space separated. There is no need to name any manpage\n"
  "\t    file here because it will be included automatically.\n"
  ;

char *author = "Robert L (Bob) Parker <rlp1938@gmail.com";

void dohelp(int forced);
char *dostrdup(const char *s);
FILE *dofopen(const char *path, const char *mode);

int main(int argc, char **argv)
{
	int opt, i, hasman, hascontrib, hasdata, hasextra;
	struct stat sb;
	char programname[FN_MAX], sources[FN_MAX], manpagename[FN_MAX],
		contribauthors[FN_MAX], readbuffer[FN_MAX], sharedata[FN_MAX];
	char cwd[PATH_MAX], extrabuild[FN_MAX];
	FILE *fpo;
	hasman = hascontrib = hasdata = hasextra = 0;

	while((opt = getopt(argc, argv, ":hm:A:d:x:")) != -1) {
		switch(opt){
		case 'h':
			dohelp(0);
		break;
		case 'm':
			hasman = 1;
			strcpy(manpagename, optarg);
			hasextra = 1;
			if(strlen(extrabuild)) {
				strcat(extrabuild, " ");
				strcat(extrabuild, optarg);
			} else {
				strcpy(extrabuild, optarg);
			}

		break;
		case 'A':
			hascontrib = 1;
			strcpy(contribauthors, optarg);
		break;
		case 'd':
			hasdata = 1;
			strcpy(sharedata, optarg);
		break;
		case 'x':
			hasextra = 1;
			if(strlen(extrabuild)) {
				strcat(extrabuild, " ");
				strcat(extrabuild, optarg);
			} else {
				strcpy(extrabuild, optarg);
			}
		break;
		case ':':
			fprintf(stderr, "Option %c requires an argument\n",optopt);
			dohelp(1);
		break;
		case '?':
			fprintf(stderr, "Illegal option: %c\n",optopt);
			dohelp(1);
		break;
		} //switch()
	}//while()
	// now process the non-option arguments

	// 1.Check that argv[???] exists.
	if (!(argv[optind])) {
		fprintf(stderr, "No program name provided\n");
		dohelp(1);
	}
	strcpy(programname, argv[optind]);

	// check for a main program.
	optind++;
	if (!(argv[optind])) {
		fprintf(stderr, "No main.c\n");
		dohelp(1);
	}
	strcpy(sources, argv[optind]);

	// concatenate other sources if any.
	optind++;
	while (argv[optind]) {
		strcat(sources, " ");
		strcat(sources, argv[optind]);
		optind++;
	}

	// link my standard files into current dir
	if (!(getcwd(cwd, PATH_MAX))){
		perror("getcwd()");
		exit(EXIT_FAILURE);
	}
	i = 0;
	while(standards[i]) {
		char path[PATH_MAX], newpath[PATH_MAX];
		strcpy(path, stdpath);
		strcat(path, standards[i]);
		strcpy(newpath, cwd);
		strcat(newpath, "/");
		strcat(newpath, standards[i]);
		if (stat(newpath, &sb) == -1) { // link only if missing
			if (link(path, newpath) == -1){
				perror(path);
			}
		}
		i++;
	}

	// generate AUTHORS
	fpo = dofopen("AUTHORS", "w");
	fprintf(fpo, "#generated by autogenam\n\n\n%s: %s\n\n", programname,
				author);
	if (hascontrib) {
		FILE *fpi = dofopen(contribauthors, "r");
		while(fgets(readbuffer, FN_MAX, fpi)){
			if (strchr(readbuffer, ':')) {
				// anything else in file is ignored.
				fputs(readbuffer, fpo);
			}
		}
		fclose(fpi);
	}
	fclose(fpo);

	// NEWS README ChangeLog
	i = 0;
	while(required[i]) {
		if(stat(required[i], &sb) == -1) { // create if missing
			fpo = dofopen(required[i], "w"); sync(); fclose(fpo);
		}
		i++;
	}

	// now generate Makefile.am
	fpo = dofopen("Makefile.am", "w");
	fprintf(fpo, "#generated by autogenam\n\n");
	fprintf(fpo, "AM_CFLAGS=-Wall -Wextra -D_GNU_SOURCE=1\n\n");
	fprintf(fpo, "bin_PROGRAMS=%s\n", programname);
	fprintf(fpo, "%s_SOURCES=%s\n\n", programname, sources);
	if (hasman)  {
		fprintf(fpo, "man_MANS=%s\n", manpagename);
	}
	if (hasdata)  {
		char line[FN_MAX];
		// ???dir=$(datadir)/???????
		strncpy(line, programname, 3);
		line[3] ='\0';
		strcat(line, "dir=$(datadir)/");
		strcat(line, programname);
		strcat(line, "\n");
		fputs(line, fpo);
		// ???_DATA=???????.conf
		line[3] = '\0';
		strcat(line, "_DATA=");
		strcat(line, sharedata);
		strcat(line, "\n");
		fputs(line, fpo);
	}
	if (hasextra){
		fprintf(fpo, "EXTRA_BUILD=%s\n", extrabuild);
	}

	fclose(fpo);

	return 0;
}//main()

void dohelp(int forced)
{
  fputs(helpmsg, stderr);
  exit(forced);
}

char *dostrdup(const char *s)
{
	/*
	 * strdup() with in built error handling
	*/
	char *cp = strdup(s);
	if(!(cp)) {
		perror(s);
		exit(EXIT_FAILURE);
	}
	return cp;
} // dostrdup()

FILE *dofopen(const char *path, const char *mode)
{
	// fopen with error handling
	FILE *fp = fopen(path, mode);
	if(!(fp)){
		perror(path);
		exit(EXIT_FAILURE);
	}
	return fp;
} // dofopen()

